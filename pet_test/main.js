// const qaPairs = [
//   {
//     "question": "Основные принципы ООП?",
//     "answer": `1. **Инкапсуляция (Encapsulation):**
//        - *Определение:* Инкапсуляция представляет собой принцип сокрытия деталей реализации и предоставления интерфейса для взаимодействия с объектом.
//        - *Пример:* Класс с методами и свойствами, где методы обеспечивают доступ к данным и их изменение, а детали реализации скрыты.


//     2. **Наследование (Inheritance):**
//        - *Определение:* Наследование позволяет создавать новый класс на основе существующего, заимствуя его свойства и методы.
//        - *Пример:* Класс "Птица" наследует от класса "Животное", получая общие характеристики, но может иметь уникальные свойства, например, "размах крыльев".


//     3. **Полиморфизм (Polymorphism):**
//        - *Определение:* Полиморфизм позволяет объектам использовать методы базового класса в специфичной для своего класса форме.
//        - *Пример:* Метод "рисовать" в различных классах (круг, квадрат) будет реализован по-разному, но интерфейс остается одинаковым.


//     4. **Абстракция (Abstraction):**
//        - *Определение:* Абстракция предоставляет упрощенное представление объекта, скрывая ненужные детали.
//        - *Пример:* Когда мы работаем с автомобилем, нас интересует его движение и управление, а не внутренние механизмы работы двигателя.


//     5. **Композиция (Composition):**
//        - *Определение:* Композиция позволяет создавать сложные объекты из более простых, объединяя их в один объект.
//        - *Пример:* Объект "Автомобиль" может включать в себя объекты "Двигатель", "Колеса" и "Руль".


//     Эти принципы обеспечивают структурирование и организацию кода в объектно-ориентированном программировании, делая его более гибким и понятным.
//     `
//   },
//   {
//     "question": "Что такое SOLID?",
//     "answer": `1. **Принцип единственной ответственности (Single Responsibility Principle - SRP):**
//        - *Определение:* Каждый класс должен иметь только одну причину для изменения.
//        - *Пример:* Класс управления базой данных не должен быть ответственен за отображение данных. Разделение ответственности улучшает поддерживаемость кода.

//     2. **Принцип открытости/закрытости (Open/Closed Principle - OCP):**
//        - *Определение:* Программные сущности должны быть открыты для расширения, но закрыты для модификации.
//        - *Пример:* Использование интерфейсов и абстрактных классов для создания расширяемых модулей без изменения исходного кода.

//     3. **Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP):**
//        - *Определение:* Объект базового класса должен быть заменяем объектом его производного класса без изменения корректности программы.
//        - *Пример:* Если у нас есть класс "Птица", то мы должны безопасно использовать его подклассы, такие как "Ласточка" или "Орёл", не нарушая логику программы.

//     4. **Принцип разделения интерфейса (Interface Segregation Principle - ISP):**
//        - *Определение:* Клиенты не должны зависеть от интерфейсов, которые они не используют.
//        - *Пример:* Разделение интерфейсов для разных клиентов, чтобы каждый клиент имел доступ только к необходимым методам.

//     5. **Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):**
//        - *Определение:* Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций.
//        - *Пример:* Внедрение зависимости (dependency injection) для обеспечения обратной зависимости между модулями.

//     Эти принципы обеспечивают структурирование и организацию кода в объектно-ориентированном программировании, делая его более гибким и понятным.
//     `
//   },
//   {
//     "question": "Разница между классовым и прототипным наследованием?",
//     "answer":  `### Разница между классовым и прототипным наследованием в JavaScript:

//     1. **Классовое наследование:**
//        - *Определение:* Введено в ECMAScript 2015 (ES6) с использованием ключевого\n слова 'class'.
//        - *Синтаксис:*\n
//          'javascript
//          class Animal {
//            constructor(name) {
//              this.name = name;
//            }

//            sound() {
//              console.log('Generic animal sound');
//            }
//          }

//          class Dog extends Animal {
//            constructor(name, breed) {
//              super(name);
//              this.breed = breed;
//            }

//            sound() {
//              console.log('Bark');
//            }
//          }

//          const myDog = new Dog('Buddy', 'Labrador');
//         '

//     2. **Прототипное наследование:**
//        - *Определение:* Базируется на использовании прототипов объектов.
//        - *Синтаксис:*
//          'javascript
//          function Animal(name) {
//            this.name = name;
//          }

//          Animal.prototype.sound = function() {
//            console.log('Generic animal sound');
//          };

//          function Dog(name, breed) {
//            Animal.call(this, name);
//            this.breed = breed;
//          }

//          Dog.prototype = Object.create(Animal.prototype);
//          Dog.prototype.constructor = Dog;

//          Dog.prototype.sound = function() {
//            console.log('Bark');
//          };

//          const myDog = new Dog('Buddy', 'Labrador');
//          '

//     **Различия:**

//     - **Синтаксис:** Классы предоставляют более удобный и декларативный синтаксис\n для создания и наследования объектов.
//     - **Ключевые слова:** В классах используются ключевые слова 'class', 'extends', и 'super', что делает код более ясным.
//     - **Прототипы:** В прототипном наследовании работа напрямую с прототипами объектов, создавая цепочку прототипов.

//     **Общее:**

//     - В классовом наследовании под капотом также используются прототипы, но скрыты от\n разработчика.
//     - Использование 'super' в классах и 'Object.create()' в прототипном наследовании для вызова конструкторов родительских классов/функций.

//     Выбор между классовым и прототипным наследованием зависит от стиля разработки и\n требований проекта. В современных приложениях классы чаще предпочтительны.
//     `
//   }
// ];




const qaPairs = [
  {
    "topic": "Основы ООП",
    "question": "Основные принципы ООП?",
    "answer": 'Основные принципы ООП:\n1. Инкапсуляция (Encapsulation):\n\n- Определение: Инкапсуляция представляет собой принцип сокрытия деталей реализации и предоставления интерфейса для взаимодействия с объектом.\n\n- Пример: Класс с методами и свойствами, где методы обеспечивают доступ к данным и их изменение, а детали реализации скрыты.\n\n2. Наследование (Inheritance):\n\n- Определение: Наследование позволяет создавать новый класс на основе существующего, заимствуя его свойства и методы.\n\n- Пример: Класс "Птица" наследует от класса "Животное", получая общие характеристики, но может иметь уникальные свойства, например, "размах крыльев".\n\n3. Полиморфизм (Polymorphism):\n\n- Определение: Полиморфизм позволяет объектам использовать методы базового класса в специфичной для своего класса форме.\n\n- Пример: Метод "рисовать" в различных классах (круг, квадрат) будет реализован по-разному, но интерфейс остается одинаковым.\n\n4. Абстракция (Abstraction):\n\n- Определение: Абстракция предоставляет упрощенное представление объекта, скрывая ненужные детали.\n\n- Пример: Когда мы работаем с автомобилем, нас интересует его движение и управление, а не внутренние механизмы работы двигателя.\n\n5. Композиция (Composition):\n\n- Определение: Композиция позволяет создавать сложные объекты из более простых, объединяя их в один объект.\n\n- Пример: Объект "Автомобиль" может включать в себя объекты "Двигатель", "Колеса" и "Руль".\n\nЭти принципы обеспечивают структурирование и организацию кода в объектно-ориентированном программировании, делая его более гибким и понятным.'
  },
  {
    "topic": "Основы ООП",
    "question": "2.	Что такое SOLID?",
    "answer": 'Основные принципы ООП:\n1. Инкапсуляция (Encapsulation):\n\n- Определение: Инкапсуляция представляет собой принцип сокрытия деталей реализации и предоставления интерфейса для взаимодействия с объектом.\n- Пример: Класс с методами и свойствами, где методы обеспечивают доступ к данным и их изменение, а детали реализации скрыты.\n\n2. Наследование (Inheritance):\n\n- Определение: Наследование позволяет создавать новый класс на основе существующего, заимствуя его свойства и методы.\n- Пример: Класс "Птица" наследует от класса "Животное", получая общие характеристики, но может иметь уникальные свойства, например, "размах крыльев".\n\n3. Полиморфизм (Polymorphism):\n\n- Определение: Полиморфизм позволяет объектам использовать методы базового класса в специфичной для своего класса форме.\n- Пример: Метод "рисовать" в различных классах (круг, квадрат) будет реализован по-разному, но интерфейс остается одинаковым.\n\n4. Абстракция (Abstraction):\n\n- Определение: Абстракция предоставляет упрощенное представление объекта, скрывая ненужные детали.\n- Пример: Когда мы работаем с автомобилем, нас интересует его движение и управление, а не внутренние механизмы работы двигателя.\n\n5. Композиция (Composition):\n\n- Определение: Композиция позволяет создавать сложные объекты из более простых, объединяя их в один объект.\n- Пример: Объект "Автомобиль" может включать в себя объекты "Двигатель", "Колеса" и "Руль".\n\nЭти принципы обеспечивают структурирование и организацию кода в объектно-ориентированном программировании, делая его более гибким и понятным.'
  },
  // ... другие вопросы ...
  {
    "topic": "Тема 2",
    "question": "Вопрос 10",
    "answer": "Ответ 10"
  },
  // ... другие вопросы ...
];

let currentPairIndex = 0;
let filteredPairs = qaPairs;

const topicSelect = document.getElementById("topic-select");
const questionElement = document.getElementById("question");
const answerElement = document.getElementById("answer");
const nextBtn = document.getElementById("next-btn");

const uniqueTopics = [...new Set(qaPairs.map(pair => pair.topic))];

uniqueTopics.forEach(topic => {
    const option = document.createElement("option");
    option.value = topic;
    option.text = topic;
    topicSelect.add(option);
});

topicSelect.addEventListener("change", () => {
    currentPairIndex = 0;
    filterPairs();
    showQA();
});

function filterPairs() {
    const selectedTopic = topicSelect.value;
    filteredPairs = qaPairs.filter(pair => pair.topic === selectedTopic);
}

function showQA() {
  if (filteredPairs.length > 0) {
      const currentPair = filteredPairs[currentPairIndex];
      questionElement.textContent = currentPair.question;
      answerElement.innerHTML = currentPair.answer.replace(/\n/g, "<br>"); // Заменяем \n на <br> для отображения переносов строк
  } else {
      questionElement.textContent = "Нет вопросов для выбранной темы.";
      answerElement.textContent = "";
  }
}

function showNextQA() {
    currentPairIndex++;
    if (currentPairIndex < filteredPairs.length) {
        showQA();
    } else {
        alert("Вы прочитали все вопросы и ответы!");
    }
}

nextBtn.addEventListener("click", showNextQA);

// Инициализация
filterPairs();
showQA();